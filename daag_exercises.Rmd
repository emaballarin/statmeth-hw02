---
title: "SMDS Homework - Block 2"
output: html_document
---

## *__DAAG__ EXERCISES*

__Exercise 11 - Cap 3__

The following data represent the total number of aberrant crypt foci (abnormal growths in the colon) observed in seven rats that had been administered a single dose of the carcinogen azoxymethane and sacrificed after six weeks (thanks to Ranjana Bird, Faculty of Human Ecology, University of Manitoba for the use of these data):

$$ \begin{matrix}
87 & 53 & 72 & 90 & 78 & 85 & 83
\end{matrix} $$
                        
Enter these data and compute their sample mean and variance. Is the Poisson model appropriate for these data? To investigate how the sample variance and sample mean differ under the Poisson assumption, repeat the following simulation experiment several times:

$$
x <- rpois(7, 78.3) \\
mean(x); var(x)
$$


*__Solution__*

```{r message=TRUE, warning=TRUE}
aberrant_crypt <- c(87, 53, 72, 90, 78, 85, 83)

paste("aberrant crypt mean:", mean(aberrant_crypt))
paste("aberrant crypt variance:", var(aberrant_crypt))

vec_mean <- c()
vec_var <- c()

for (i in 0:100){
  x <- rpois(7, 78.28)
  vec_mean <- c(vec_mean, mean(x))
  vec_var <- c(vec_var, var(x))
}

paste("poisson mean simulation:", mean(vec_mean))
paste("poisson variance simulation:", mean(vec_var))
```


__Exercise 13 - Cap 3__

A Markov chain for the weather in a particular season of the year has the transition matrix, from one day to the next:

$$ Pb = \begin{bmatrix}
      & sun & cloud & rain\\ 
sun   & 0.6 & 0.2   & 0.2\\ 
cloud & 0.2 & 0.4   & 0.4\\ 
rain  & 0.4 & 0.3   & 0.3
\end{bmatrix} $$

It can be shown, using linear algebra, that in the long run this Markov chain will visit the states according to the stationary distribution:

$$ \begin{matrix}
sun   & cloud & rain\\ 
0.641 & 0.208 & 0.151
\end{matrix} $$

A result called the ergodic theorem allows us to estimate this distribution by simulating the Markov chain for a long enough time.

a) Simulate 1000 values, and calculate the proportion of times the chain visits each of the states. Compare the proportions given by the simulation with the above theoretical proportions.

b) Here is code that calculates rolling averages of the proportions over a number of simulations and plots the result. It uses the function rollmean() from the zoo package. Try varying the number of simulations and the width of the window. How wide a window is needed to get a good sense of the stationary distribution? This series settles down rather quickly to its stationary distribution (it “burns in” quite quickly). A reasonable width of window is, however, needed to give an accurate indication of the stationary distribution.

*__Solution__*

__a)__

```{r}
Markov <- function(n, start, transition){
  
}
```

__b)__

```{r}
library(zoo)
library(markovchain)

Pb <- matrix(data=c(0.6, 0.2, 0.2, 0.2, 0.4, 0.4, 0.4, 0.3, 0.3), nrow=3, ncol=3)
Pb
```


__Exercise 6 - Cap 4__

Here we generate random normal numbers with a sequential dependence structure:

```{r}
y1 <- rnorm(51)
y <- y1[-1] + y1[-51]
acf(y1)  # acf is ‘autocorrelation function’
# (see Chapter 9)
acf(y)
```

Repeat this several times. There should be no consistent pattern in the acf plot for different random samples y1. There will be a fairly consistent pattern in the acf plot for y, a result of the correlation that is introduced by adding to each value the next value in the sequence.

*__Solution__*

```{r}
par(mfrow=c(3, 2))
for(i in 1:3){
  y1 <- rnorm(51)
  y <- y1[-1] + y1[-51]
  acf(y1)  # acf is ‘autocorrelation function’
  # (see Chapter 9)
  acf(y)
}
```


__Exercise 13 - Cap 4__

Create a function that does the calculations in the first two lines of the previous exercise. Put the calculation in a loop that repeats 25 times. Calculate the mean and variance for each vector y that is returned. Store the 25 means in the vector av, and store the 25 variances in the vector v. Calculate the variance of av.

*__Solution__*

```{r}
corr <- function(){
  y1 <- rnorm(51)
  y <- y1[-1] + y1[-51]
  return(y)
}

computation <- replicate(25, corr(), simplify=FALSE)

av <- c()
v <- c()
for(i in 1:25){
  av <- c(av, mean(computation[[i]]))
  v <- c(v, var(computation[[i]]))
}

var_v <- var(v)
```

